# JAVA基础

## 1.面向过程与面向对象

### 面向过程

优点：性能高（因为面向对象类调用时需要实例化，开销大，消耗资源）

缺点：没有面型对象易维护 易复用 易扩展

### 面向对象

优点：易维护 易复用 易扩展，具有封装多态继承的特性，可以设计出低耦合的系统，是系统更加灵活和更加易于维护

缺点：性能低

## 2.Java语言的特点

1. 简单易学；
2. 面向对象（封装，继承，多态）；
3. 平台无关性（ Java 虚拟机实现平台无关性）；
4. 可靠性；
5. 安全性；
6. 支持多线程（ C++ 语言没有内置的多线程机制，因此必须调用操作系统的多线程功能来进行多线程程序设计，而 Java 语言却提供了多线程支持）；
7. 支持网络编程并且很方便（ Java 语言诞生本身就是为简化网络编程设计的，因此 Java 语言不仅支持网络编程而且很方便）；
8. 编译与解释并存；

## 3.JVM，JDK，与JRE

### JVM

java虚拟机（jvm）是运行java字节码的虚拟机。他在不同系统上都有特定的实现，这是为了实现实现在不同机器上jvm运行相同字节码都能给出同样的结果，实现java语言的可移植性（write once，run anywhere）

![1560395674007](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1560395674007.png)

### JDK与JRE

JDK是java development kit，他是功能齐全的java sdk。jdk包含了jre的所有内容，包括了java编译器（javac）和工具（javadoc）以及一些其构件。可以创建和运行程序。

jre是java运行时环境，它是用来运行已编译的java程序所需的所有内容的集合，包括jvm，java类库和java命令和一些其他的构件。它不创建新程序。



## 4.Oracle JDK与Open JDK

二者非常接近，可以说Oracle JDK是在Open JDK上的一个实现，多了一些部分，更加稳定高性能些，适用于商业企业开发。而Open JDK开源的，每三个月就发布一个新版本，而Oracle JDK每三年才发布一次。Oracle JDK是基于二进制代码许可协议的，而Open JDK是GPL v2许可。

## 5.Java和C++的区别

- java和c++都是面向对象语言，支持多态封装继承
- java不提供指针直接访问内存，程序内存更加安全
- java类不支持多继承。但java接口支持多继承
- java有自动内存管理机制，不需要手动释放内存

## 6. Java 程序的主类 应用程序和小程序的主类有何不同?

一个程序可以有多个类，但只能有一个主类。在java应用程序中主类是包含main（）方法的那个类（不要求一定是public）。而小程序主类是指及继承自Applet或JApplet的类，且要求一定是public。主类是程序的入口。

## 7. Java 应用程序与小程序之间有那些差别?

应用程序是从主线程启动（也就是main（）方法）。而小程序主要嵌在浏览器中运行（通过init（）或者run（）来启动）。

## 8.字符型常量和字符串常量的区别?

1. 形式上：字符型常量由单引号表示，字符串由双引号
2. 含义上：字符型常量相当于一个整型值（Ascii值）可以参与表达式运算。字符串常量代表一个地址值（该字符串在内存中存放的地址）
3. 占内存大小：字符：2字节   字符串：若干个字节

## 9.构造器 Constructor 是否可被 override?

可以重载但是不能重写（override）以为父类的私有属性和构造函数不能被继承。

## 10.重写和重载的区别

重写：发生在父子类中，方法名参数列表必须相同。返回值范围小于等于父类，抛出的异常范围下雨等于父类，访问修饰符范围大于等于父类。如果父类是private，则不能重写。

重载：发生在同一个类中，方法名必须相同，参数类型不同，参数个数不同，顺序不同，返回值和访问修饰符可以不同，发生在编译时。

## 11. Java 面向对象编程三大特性: 封装 继承 多态

### 封装

封装把一个对象的属性私有化，同时提供一些可以被外界访问的属性方法，如果属性不想被外界访问，就不提供属性的方法。

### 继承

继承是使用已存在的类的定义作为基础建立新类的技术，可以增加新的数据和功能，也可以是用父类的功能，但是不能选择性的继承父类。通过继承我们能方便的使用以前的代码。

继承的3个要点：

1. 子类是拥有父类的所有属性和方法，但是父类中的私有属性和方法子类不能访问，只是拥有。
2. 子类可以有自己的属性和方法，是对父类的扩展
3. 子类可以自己的方式来实现父类的方法。

### 多态

指程序中定义的引用变量所指向具体类型和通过该引用变量放出的方法调用在编程时不确定，而是运行期间才确定，即一个引用变量到底会指向哪个类的具体实例，以及发出的方法调用到底是哪个类中的实现方法。必须在程序运行期间才能确定。

## 12. String StringBuffer 和 StringBuilder 的区别是什么? String 为什么是不可变的?



### 可变性

String中使用final关键字修饰的字符数组来保存字符串，因此是不可变的。而StringBuilder与StringBuffer都继承自AbstractStringBuilder类。其实现如下

AbstractStringBuilder.java

```java
abstract class AbstractStringBuilder implements Appendable, CharSequence {
    char[] value;
    int count;
    AbstractStringBuilder() {
    }
    AbstractStringBuilder(int capacity) {
        value = new char[capacity];
    }
```

### 线程安全性

String 中的对象是不可变的，也就可以理解为常量，线程安全。AbstractStringBuilder 是 StringBuilder 与 StringBuffer 的公共父类，定义了一些字符串的基本操作，如 expandCapacity、append、insert、indexOf 等公共方法。StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。 　　

### 性能

每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后将指针指向新的 String 对象。StringBuffer 每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 StringBuilder 相比使用 StringBuffer 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。

**对于三者使用的总结：**

1. 操作少量的数据: 适用String
2. 单线程操作字符串缓冲区下操作大量数据: 适用StringBuilder
3. 多线程操作字符串缓冲区下操作大量数据: 适用StringBuffer

## 13.自动装箱与拆箱

装箱：将基本类型用他们对应的引用类型包装起来

拆箱：将包装类型转换为基本类型

## 14. 在一个静态方法内调用一个非静态成员为什么是非法的?

静态方法可以不通过对象进行调用，因此在静态方法里，不能调用其他非静态变量，也不可以访问非静态变量成员。

## 15. 在 Java 中定义一个不做事且没有参数的构造方法的作用

如果父类之定义了有参数的构造方法，那子类没有使用super（）来调用父类特定构造方法是就找不到没有参数的构造方法，造成编译错误。

## 16. import java和javax有什么区别？

刚开始的时候 JavaAPI 所必需的包是 java 开头的包，javax 当时只是扩展 API 包来使用。然而随着时间的推移，javax 逐渐地扩展成为 Java API 的组成部分。但是，将扩展从 javax 包移动到 java 包确实太麻烦了，最终会破坏一堆现有的代码。因此，最终决定 javax 包将成为标准API的一部分。

所以，实际上java和javax没有区别。这都是一个名字。

## 17.接口与抽象类的区别

1. 接口的方法默认是public的，所有的方法在接口不能实现（在java8开始可以有默认实现），而抽象类可以有非抽象方法
2. 接口中除了static，final变量不能有其他变量，而抽象类中不一定
3. 一个类可以实现过个接口，但只能实现一个抽象类。接口本身可以通过extends扩展多个接口
4. 接口方法默认修饰符是public，而抽象方法可以由public protected default这些修饰符（抽象方法就是为了被重写所以不能使用private关键字修饰！)
5. 冲设计层面看，抽象类是对类的抽象，是一种模板设计，而接口是对行为的抽象，是一种行为规范。

## 18.成员变量与局部变量的区别.

1. 成员变量是属于类的，而局部变量是方法内定义的变量或方法参数。成员变量可以有public private static等修饰符修饰，而局部变量不能别访问控制符和static所修饰。但他们都可以用final修饰
2. 从变量在内存中的存储方式来看:如果成员变量是使用`static`修饰的，那么这个成员变量是属于类的，如果没有使用`static`修饰，这个成员变量是属于实例的。而对象存在于堆内存，局部变量则存在于栈内存。
3. 从变量在内存中的生存时间上看:成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动消失。
4. 成员变量如果没有被赋初值:则会自动以类型的默认值而赋值（一种情况例外被 final 修饰的成员变量也必须显示地赋值），而局部变量则不会自动赋值。

## 19.创建一个对象用什么运算符?对象实体与对象引用有何不同？



new用于创建对象实例（堆内存），对象引用指向对象实例（对象引用放在栈内存中）一个对象引用可以指向0个或1个对象，一个对象可以被多个引用所指。

## 20. 什么是方法的返回值?返回值在类的方法里的作用是什么?

返回值就是指执行某个方法体后输出的结果（void不返回结果），作用是接收结果，使得它可以用于其他的操作。

## 21. 一个类的构造方法的作用是什么? 若一个类没有声明构造方法，该程序能正确执行吗? 为什么?

构造方法的作用是来完成类对象的初始化操作。可以执行，会有一个默认的无参构造方法。

## 22.构造方法有哪些特性？

1. 与类名名字相同
2. 没有返回值，但不是void类函数
3. 生成类的对象时自动执行，无须调用

## 23. 静态方法和实例方法有何不同

1. 在外部调用静态方法时，可以使用“类名.静态方法",与”对象名.静态方法".而实例方法允许后一种。即静态方法调用可以不创建对象。
2. 静态方法在访问本类成员时，只允许访问静态成员（静态成员变量和静态成员方法）而实例方法没有此限制。

## 24. 对象的相等与指向他们的引用相等,两者有什么不同?

对象的相等，比的是内存中存放的内容是否相等。而引用相等，比较的是他们指向的内存地址是否相等

## 25. 在调用子类构造方法之前会先调用父类没有参数的构造方法,其目的是?

帮助子类做初始化操作

## 26. == 与 equals(重要)

**==** : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象(基本数据类型==比较的是值，引用数据类型==比较的是内存地址)。

**equals()** : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况：

- 情况1：类没有覆盖 equals() 方法。则通过 equals() 比较该类的两个对象时，等价于通过“==”比较这两个对象。
- 情况2：类覆盖了 equals() 方法。一般，我们都覆盖 equals() 方法来比较两个对象的内容是否相等；若它们的内容相等，则返回 true (即，认为这两个对象相等)。

**举个例子：**

```java
public class test1 {
    public static void main(String[] args) {
        String a = new String("ab"); // a 为一个引用
        String b = new String("ab"); // b为另一个引用,对象的内容一样
        String aa = "ab"; // 放在常量池中
        String bb = "ab"; // 从常量池中查找
        if (aa == bb) // true
            System.out.println("aa==bb");
        if (a == b) // false，非同一对象
            System.out.println("a==b");
        if (a.equals(b)) // true
            System.out.println("aEQb");
        if (42 == 42.0) { // true
            System.out.println("true");
        }
    }
}
```

**说明：**

- String 中的 equals 方法是被重写过的，因为 object 的 equals 方法是比较的对象的内存地址，而 String 的 equals 方法比较的是对象的值。
- 当创建 String 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个 String 对象



## 27. hashCode 与 equals (重要)

面试官可能会问你：“你重写过 hashcode 和 equals 么，为什么重写equals时必须重写hashCode方法？”

### hashCode（）介绍

hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个int整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode() 定义在JDK的Object.java中，这就意味着Java中的任何类都包含有hashCode() 函数。

散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）

### 为什么要有 hashCode

**我们先以“HashSet 如何检查重复”为例子来说明为什么要有 hashCode：** 当你把对象加入 HashSet 时，HashSet 会先计算对象的 hashcode 值来判断对象加入的位置，同时也会与其他已经加入的对象的 hashcode 值作比较，如果没有相符的hashcode，HashSet会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用 `equals（）`方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。（摘自我的Java启蒙书《Head first java》第二版）。这样我们就大大减少了 equals 的次数，相应就大大提高了执行速度。

通过我们可以看出：`hashCode()` 的作用就是**获取哈希码**，也称为散列码；它实际上是返回一个int整数。这个**哈希码的作用**是确定该对象在哈希表中的索引位置。**`hashCode() `在散列表中才有用，在其它情况下没用。**在散列表中hashCode() 的作用是获取对象的散列码，进而确定该对象在散列表中的位置。

### hashCode（）与equals（）的相关规定

1. 如果两个对象相等，则hashcode一定也是相同的
2. 两个对象相等,对两个对象分别调用equals方法都返回true
3. 两个对象有相同的hashcode值，它们也不一定是相等的
4. **因此，equals 方法被覆盖过，则 hashCode 方法也必须被覆盖**
5. hashCode() 的默认行为是对堆上的对象产生独特值。如果没有重写 hashCode()，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）

推荐阅读：[Java hashCode() 和 equals()的若干问题解答](https://www.cnblogs.com/skywang12345/p/3324958.html)

## 28. 为什么Java中只有值传递？

**Java程序设计语言总是采用按值调用。也就是说，方法得到的是所有参数值的一个拷贝，也就是说，方法不能修改传递给它的任何参数变量的内容。**

ava程序设计语言对对象采用的不是引用调用，实际上，对象引用是按 值传递的。

下面再总结一下Java中方法参数的使用情况：

- 一个方法不能修改一个基本数据类型的参数（即数值型或布尔型）。
- 一个方法可以改变一个对象参数的状态。
- 一个方法不能让对象参数引用一个新的对象。

## 29. 简述线程、程序、进程的基本概念。以及他们之间关系是什么?

**线程**与进程类似，是比进程更小的一个执行单位。一个进程在执行过程中可以产生多个线程。与进程不同的是同类的多个线程共享同一块内存空间和一组系统资源，所以系统在产生一个线程是或者在不同线程之间切换时，负担要比进程小的多。

**程序**是指指令和数据的文件。也可以说是静态的代码。

**进程**

是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序，就是进程从创建运行到消亡的过程。简单来说，一个进程就是一个执行中的程序，它在计算机中一个指令接着一个指令地执行着，同时，每个进程还占有某些系统资源如CPU时间，内存空间，文件，文件，输入输出设备的使用权等等。换句话说，当程序在执行时，将会被操作系统载入内存中。 线程是进程划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。从另一角度来说，进程属于操作系统的范畴，主要是同一段时间内，可以同时执行一个以上的程序，而线程则是在同一程序内几乎同时执行一个以上的程序段

## 30.线程的基本状态

线程在运行时的转载只可能下面6种中的一种

| 状态名称     | 说明                                                         |
| ------------ | ------------------------------------------------------------ |
| new          | 初始状态，指进程已经被构建还没开始运行                       |
| runnable     | 运行状态，java线程把操作系统中的就绪与运行都叫做运行中       |
| blocked      | 阻塞转态，表示线程阻塞于锁                                   |
| waiting      | 等待转态，表示线程进入等待，需要等待其他线程的一些特定的操作（通知或中断） |
| time_waiting | 超时等待状态，与waiting不同，他可以在规定时间自行返回        |
| terminated   | 终止转态，表示当前线程已经执行完毕                           |

## 31 关于 final 关键字的一些总结

final主要用于是哪个地方：变量方法与类

1. 对于一个final变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。
2. 当用final修饰一个类时，表明这个类不能被继承。final类中的所有成员方法都会被隐式地指定为final方法。
3. 使用final方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义；第二个原因是效率。在早期的Java实现版本中，会将final方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升（现在的Java版本已经不需要使用final方法进行这些优化了）。类中所有的private方法都隐式地指定为final。

可以参考博客https://blog.csdn.net/weixin_44271683/article/details/87859929

## 32 Java 中的异常处理

java异常类层次结构图

![68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d322f457863657074696f6e2e706e67 (600Ã377)](https://camo.githubusercontent.com/27aa104d93ba0738be0f3d2e7d5b096c1619d12d/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d322f457863657074696f6e2e706e67)

java异常类的共同祖先是Throwable类，其有两个子类：Error错误类与Exception异常类。二者都是异常处理的重要类，都包含大量子类。

Error是程序无法处理的错误。这些错误表示的故障发生于虚拟机本身或者发生在虚拟机试图执行应用时。

Exception是程序本身可以处理的异常.它有一个重要的子类RuntimeException运行时异常，由虚拟机抛出。如空指针，算数运算，数组越界等异常都是运行时异常。

### hrowable类常用方法

- **public string getMessage()**:返回异常发生时的详细信息
- **public string toString()**:返回异常发生时的简要描述
- **public string getLocalizedMessage()**:返回异常对象的本地化信息。使用Throwable的子类覆盖这个方法，可以声称本地化信息。如果子类没有覆盖该方法，则该方法返回的信息与getMessage（）返回的结果相同
- **public void printStackTrace()**:在控制台上打印Throwable对象封装的异常信息

### 异常处理总结

- **try 块：**用于捕获异常。其后可接零个或多个catch块，**如果没有catch块，则必须跟一个finally块**。
- **catch 块：**用于处理try捕获到的异常。
- **finally 块：**无论是否捕获或处理异常，finally块里的语句都会被执行。**当在try块或catch块中遇到return语句时，finally语句块将在方法返回之前被执行。**

**在以下4种特殊情况下，finally块不会被执行：**

1. 在finally语句块第一行发生了异常。 因为在其他行，finally块还是会得到执行
2. 在前面的代码中用了System.exit(int)已退出程序。 exit是带参函数 ；若该语句在异常语句之后，finally会执行
3. 程序所在的线程死亡。
4. 关闭CPU。



**关于返回值：**

如果try语句里有return，返回的是try语句块中变量值。 详细执行过程如下：

1. 如果有返回值，就把返回值保存到局部变量中；
2. 执行jsr指令跳到finally语句里执行；
3. 执行完finally语句后，返回之前保存在局部变量表里的值。
4. **如果try，finally语句里均有return，忽略try的return，而使用finally的return.**

## 33. Java序列化中如果有些字段不想进行序列化，怎么办？

对于不想进行序列化的变量，使用transient关键字来修饰。

被transient关键字修饰的变量不会被序列化，反序列化时也不会被持久化和恢复。

transien只能修饰变量不能修饰类和方法。

## 34 获取用键盘输入常用的的两种方法

1.Scanner

```java
Scanner in=new Scanner(System.in);
String s= in.nextLine();
in.close();
```

2.BufferedReader

```java
BufferedReader input =new BufferedReader(new InputStreamReader(System.in))；
String s=input.readLine();
```

## 35.Java 中 IO 流分为几种?BIO,NIO,AIO 有什么区别?

### java 中 IO 流的分类

- 按照流的流向分，可以分为输入流和输出流；
- 按照操作单元划分，可以划分为字节流和字符流；
- 按照流的角色划分为节点流和处理流。

javaIO的4个抽象类基类

- InputStream/Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。
- OutputStream/Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。

按操作方式分类结构图：

![68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f352f31362f313633363764346664316365316234363f773d37323026683d3130383026663d6a70656726733d3639353232 (720Ã1080)](https://camo.githubusercontent.com/50f105c85f6b42d643d46e1ac7bb0f855b92cd9d/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f352f31362f313633363764346664316365316234363f773d37323026683d3130383026663d6a70656726733d3639353232)

按操作对象分类结构图：

![68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f352f31362f313633363764363733623065323638643f773d37323026683d35333526663d6a70656726733d3436303831 (720Ã535)](https://camo.githubusercontent.com/8957efacdf1cd4eac15d844da8353a7f77a3c863/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f352f31362f313633363764363733623065323638643f773d37323026683d35333526663d6a70656726733d3436303831)

- BIO同步阻塞IO模式，数据的读取写入必须阻塞在一个线程内等待完成。当活动连接数比较小的时候，他是简单好用的，但是无法处理高并发连接数比较多的场景。
- NIO同步非阻塞IO模式，对于高负载、高并发的（网络）应用，应使用 NIO 的非阻塞模式来开发
- AIO异步非阻塞IO模型 是NIO的改进版，异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作

具体可参考https://blog.csdn.net/charjay_lin/article/details/81810922

## 36. 常见关键字总结:static,final,this,super

关于final与static可参考我的博客https://blog.csdn.net/weixin_44271683/article/details/87859929

this与super可参考https://blog.csdn.net/zhuwei1035838807/article/details/79156820

## 37. Collections 工具类和 Arrays 工具类常见方法总结

可参考码云博客https://gitee.com/SnailClimb/JavaGuide/blob/master/docs/java/Basis/Arrays,CollectionsCommonMethods.md